{{ define "main" }}
  <!-- App Bar CSS -->
  {{- $appBarCSS := resources.Get "css/app-bar.css" -}}
  {{- if $appBarCSS -}}
    {{- if hugo.IsProduction -}}
      {{- $appBarCSS = $appBarCSS | minify | fingerprint -}}
    {{- end -}}
    <link rel="stylesheet" href="{{ $appBarCSS.RelPermalink }}" />
  {{- end -}}


  <!-- Shadertoy Clouds CSS -->
  {{- $cloudCSS := resources.Get "css/shadertoy-clouds.css" -}}
  {{- if $cloudCSS -}}
    {{- if hugo.IsProduction -}}
      {{- $cloudCSS = $cloudCSS | minify | fingerprint -}}
    {{- end -}}
    <link rel="stylesheet" href="{{ $cloudCSS.RelPermalink }}" />
  {{- end -}}

  <!-- Custom Overrides CSS to fix theme conflicts -->
  {{- $overridesCSS := resources.Get "css/custom-overrides.css" -}}
  {{- if $overridesCSS -}}
    {{- if hugo.IsProduction -}}
      {{- $overridesCSS = $overridesCSS | minify | fingerprint -}}
    {{- end -}}
    <link rel="stylesheet" href="{{ $overridesCSS.RelPermalink }}" />
  {{- end -}}


  <!-- Skip to content for keyboard users -->
  <a class="skip-to-content" href="#mainContent">Skip to content</a>

  <!-- Screen reader description for cloud scene -->
  <div class="sr-only" role="region" aria-label="Animated cloud scene">
    An animated 3D cloud scene with the text "BASEET STUDIO". Scroll down to navigate through the clouds and reach the
    main content.
  </div>

  <!-- Cloud Canvas Container -->
  <div class="cloud-canvas-container" id="cloudCanvasContainer">
    <canvas id="cloudCanvas" aria-label="3D volumetric cloud animation"></canvas>
  </div>

  <!-- Scroll Indicator -->
  <div class="scroll-indicator" id="scrollIndicator">
    <span>Scroll to explore</span>
    <div class="scroll-indicator-icon"></div>
  </div>

  <!-- App Bar Header -->
  {{ partial "header.html" . }}


  <main id="mainContent" class="main-content-wrapper">
    <!-- Main content -->
    {{ with site.Data.home.hero }}{{ if .enable }}{{ partial "blocks/home/hero" . }}{{ end }}{{ end }}
    {{ with site.Data.home.features }}{{ if .enable }}{{ partial "blocks/home/features" . }}{{ end }}{{ end }}
    {{ with site.Data.home.team }}{{ if .enable }}{{ partial "blocks/home/team" . }}{{ end }}{{ end }}
    {{ with site.Data.home.highlights }}{{ if .enable }}{{ partial "blocks/home/highlights" . }}{{ end }}{{ end }}
    {{ with site.Data.home.clients }}{{ if .enable }}{{ partial "blocks/home/clients" . }}{{ end }}{{ end }}


    <!-- Performance Optimization Script -->
    {{- $performance := resources.Get "js/performance.js" -}}
    {{- if $performance -}}
      <script src="{{ $performance.Permalink }}" defer fetchpriority="high"></script>
    {{- end -}}


    <!-- Enhanced Animations Script -->
    {{- $animations := resources.Get "js/animations.js" -}}
    {{- if $animations -}}
      <script src="{{ $animations.Permalink }}" defer fetchpriority="high"></script>
    {{- end -}}


    <!-- AJAX Form Handler -->
    {{- $formHandler := resources.Get "js/form-handler.js" -}}
    {{- if $formHandler -}}
      <script src="{{ $formHandler.Permalink }}" defer fetchpriority="low"></script>
    {{- end -}}


    <!-- Preconnect to external domains for faster loading -->
    <link rel="preconnect" href="https://images.unsplash.com" crossorigin />
    <link rel="dns-prefetch" href="https://formspree.io" />

    <!-- Import map for Three.js modules -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/": "https://cdn.jsdelivr.net/npm/three@0.160.0/"
        }
      }
    </script>

    <!-- Shadertoy Cloud System - Inline version -->
    <script type="module">
      import * as THREE from 'three';

      // Initialize cloud renderer when DOM is ready
      async function initCloudSystem() {
        try {
          console.log('Initializing inline cloud system...');

          const canvas = document.getElementById('cloudCanvas');
          if (!canvas) {
            console.error('Canvas not found!');
            return;
          }
          console.log('Canvas found');

          // Create scene
          const scene = new THREE.Scene();
          console.log('Scene created');

          // Create orthographic camera for full-screen shader
          const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
          console.log('Camera created');

          // Create renderer
          const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            alpha: false,
            antialias: false
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor(0x000000, 1);
          console.log('Renderer created');

          // Create noise texture
          const size = 256;
          const data = new Uint8Array(size * size * 4);
          let seed = 12345;
          const seededRandom = () => {
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            return seed / 0x7fffffff;
          };
          for (let i = 0; i < size * size; i++) {
            const idx = i * 4;
            data[idx] = Math.floor(seededRandom() * 256);
            data[idx + 1] = Math.floor(seededRandom() * 256);
            data[idx + 2] = Math.floor(seededRandom() * 256);
            data[idx + 3] = 255;
          }
          const noiseTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
          noiseTexture.wrapS = THREE.RepeatWrapping;
          noiseTexture.wrapT = THREE.RepeatWrapping;
          noiseTexture.minFilter = THREE.LinearFilter;
          noiseTexture.magFilter = THREE.LinearFilter;
          noiseTexture.needsUpdate = true;
          console.log('Noise texture created');

          // Create shader material
          const cloudMaterial = new THREE.ShaderMaterial({
            uniforms: {
              uTime: { value: 0.0 },
              uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
              uMouse: { value: new THREE.Vector2(0.5, 0.5) },
              uChannel0: { value: noiseTexture },
              uChannel1: { value: noiseTexture }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform float uTime;
              uniform vec2 uResolution;
              uniform vec2 uMouse;
              uniform sampler2D uChannel0;
              uniform sampler2D uChannel1;
              varying vec2 vUv;

              float noise(in vec3 x) {
                vec3 p = floor(x);
                vec3 f = fract(x);
                f = f * f * (3.0 - 2.0 * f);
                vec2 uv = (p.xy + vec2(37.0, 239.0) * p.z) + f.xy;
                vec2 rg = texture2D(uChannel0, (uv + 0.5) / 256.0).yx;
                return mix(rg.x, rg.y, f.z) * 2.0 - 1.0;
              }

              float map(in vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * uTime * 0.1;
                float f = 0.5 * noise(q);
                q *= 2.0;
                f += 0.25 * noise(q);
                q *= 2.0;
                f += 0.125 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
              }

              void main() {
                vec2 fragCoord = vUv * uResolution;
                vec2 p = (2.0 * fragCoord - uResolution) / uResolution.y;

                float an = 0.5 * uTime * 0.1 + uMouse.x * 3.0;
                vec3 ro = vec3(4.0 * sin(an), 0.5, 4.0 * cos(an));
                vec3 ta = vec3(0.0, -1.0, 0.0);
                vec3 ww = normalize(ta - ro);
                vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
                vec3 vv = cross(uu, ww);
                vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);

                vec3 col = vec3(0.6, 0.71, 0.75) - rd.y * 0.2 * vec3(1.0, 0.5, 1.0) + 0.15;

                float t = 0.0;
                vec4 sum = vec4(0.0);
                for (int i = 0; i < 64; i++) {
                  vec3 pos = ro + t * rd;
                  if (sum.a > 0.99 || pos.y < -3.0 || pos.y > 2.0) break;

                  float den = map(pos);
                  if (den > 0.01) {
                    vec4 c = vec4(mix(vec3(1.0, 0.95, 0.8), vec3(0.25, 0.3, 0.35), den), den);
                    c.xyz = mix(c.xyz, col, 1.0 - exp(-0.003 * t * t));
                    c.w *= 0.4;
                    c.rgb *= c.a;
                    sum += c * (1.0 - sum.a);
                  }
                  t += max(0.06, 0.02 * t);
                }

                col = col * (1.0 - sum.w) + sum.xyz;
                gl_FragColor = vec4(col, 1.0);
              }
            `,
            transparent: false,
            depthWrite: false,
            side: THREE.DoubleSide
          });
          console.log('Shader material created');

          // Create plane
          const geometry = new THREE.PlaneGeometry(2, 2);
          const mesh = new THREE.Mesh(geometry, cloudMaterial);
          mesh.frustumCulled = false;
          scene.add(mesh);
          console.log('Mesh added to scene');

          // Store for scroll control
          window.cloudRenderer = { 
            material: cloudMaterial,
            updateScroll: (p) => {},
            reset: () => {}
          };

          // Animate
          const startTime = Date.now();
          function animate() {
            requestAnimationFrame(animate);
            cloudMaterial.uniforms.uTime.value = (Date.now() - startTime) / 1000.0;
            renderer.render(scene, camera);
          }
          animate();
          console.log('Animation started - clouds should be visible!');

          // Resize handler
          window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            cloudMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
          });

          // Handle scroll transition
          let scrollProgress = 0;
          window.addEventListener('scroll', () => {
            const scrollY = window.scrollY || window.pageYOffset;
            scrollProgress = Math.min(scrollY / 600, 1.0);
            
            if (scrollProgress >= 1.0) {
              handleTransitionComplete();
            }
          });

        } catch (error) {
          console.error('Failed to initialize cloud system:', error);
          handleWebGLFallback();
        }
      }

      // Handle transition complete (scroll reached 100%)
      function handleTransitionComplete() {
        const body = document.body;
        const mainContent = document.querySelector('.main-content-wrapper');
        const cloudContainer = document.getElementById('cloudCanvasContainer');
        const scrollIndicator = document.getElementById('scrollIndicator');

        // Add revealing class to start transition
        body.classList.add('revealing');
        if (mainContent) {
          mainContent.classList.add('revealing');
        }

        // Hide scroll indicator
        if (scrollIndicator) {
          scrollIndicator.classList.add('hidden');
        }

        // After transition, add loaded class and hide clouds
        setTimeout(() => {
          body.classList.add('loaded');
          if (mainContent) {
            mainContent.classList.add('loaded');
          }
          if (cloudContainer) {
            cloudContainer.classList.add('fade-out');
          }
        }, 800);
      }

      // Handle transition reset (scrolled back to top)
      function handleTransitionReset() {
        const body = document.body;
        const mainContent = document.querySelector('.main-content-wrapper');
        const cloudContainer = document.getElementById('cloudCanvasContainer');
        const scrollIndicator = document.getElementById('scrollIndicator');

        // Remove all transition classes
        body.classList.remove('revealing', 'loaded');
        if (mainContent) {
          mainContent.classList.remove('revealing', 'loaded');
        }
        if (cloudContainer) {
          cloudContainer.classList.remove('fade-out');
        }

        // Show scroll indicator again
        if (scrollIndicator) {
          scrollIndicator.classList.remove('hidden');
        }
      }

      // Handle WebGL fallback (no WebGL support)
      function handleWebGLFallback() {
        console.warn('WebGL not supported, showing content immediately');
        const body = document.body;
        const mainContent = document.querySelector('.main-content-wrapper');
        const cloudContainer = document.getElementById('cloudCanvasContainer');
        const scrollIndicator = document.getElementById('scrollIndicator');

        // Hide cloud elements
        if (cloudContainer) {
          cloudContainer.style.display = 'none';
        }
        if (scrollIndicator) {
          scrollIndicator.style.display = 'none';
        }

        // Show content immediately
        body.classList.add('loaded');
        if (mainContent) {
          mainContent.classList.add('loaded');
          mainContent.style.paddingTop = '0';
        }
      }

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCloudSystem);
      } else {
        initCloudSystem();
      }
    </script>
  </main>
{{ end }}
