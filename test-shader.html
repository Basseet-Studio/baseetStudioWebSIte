<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Test</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #cloudCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #333;
        }
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
            max-width: 400px;
        }
        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="cloudCanvas"></canvas>
    <div id="debug">Loading...</div>
    <div id="controls">
        <button onclick="setMode(0)">Mode 0: Normal</button>
        <button onclick="setMode(1)">Mode 1: UV</button>
        <button onclick="setMode(2)">Mode 2: Coords</button>
        <button onclick="setMode(3)">Mode 3: Ray</button>
        <button onclick="setMode(4)">Mode 4: Noise</button>
        <button onclick="setMode(5)">Mode 5: Blue</button>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/": "https://cdn.jsdelivr.net/npm/three@0.160.0/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        
        const debugEl = document.getElementById('debug');
        let renderer, cloudMaterial;
        
        function log(msg) {
            console.log(msg);
            debugEl.innerHTML += '<br>' + (typeof msg === 'object' ? JSON.stringify(msg, null, 2) : msg);
        }
        
        window.setMode = function(mode) {
            if (cloudMaterial && cloudMaterial.uniforms.uDebugMode) {
                cloudMaterial.uniforms.uDebugMode.value = parseFloat(mode);
                log('Set debug mode to: ' + mode);
            }
        };
        
        async function init() {
            try {
                debugEl.innerHTML = 'Initializing...';
                
                const canvas = document.getElementById('cloudCanvas');
                log('Canvas found: ' + !!canvas);
                
                // Create scene
                const scene = new THREE.Scene();
                log('Scene created');
                
                // Create orthographic camera for full-screen shader
                const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
                log('Camera created');
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    alpha: false,
                    antialias: false
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 1);
                log('Renderer created: ' + window.innerWidth + 'x' + window.innerHeight);
                
                // Check WebGL context
                const gl = renderer.getContext();
                log('WebGL version: ' + gl.getParameter(gl.VERSION));
                log('GLSL version: ' + gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
                
                // Create noise texture
                const size = 256;
                const data = new Uint8Array(size * size * 4);
                let seed = 12345;
                const seededRandom = () => {
                    seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                    return seed / 0x7fffffff;
                };
                for (let i = 0; i < size * size; i++) {
                    const idx = i * 4;
                    data[idx] = Math.floor(seededRandom() * 256);
                    data[idx + 1] = Math.floor(seededRandom() * 256);
                    data[idx + 2] = Math.floor(seededRandom() * 256);
                    data[idx + 3] = 255;
                }
                const noiseTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
                noiseTexture.wrapS = THREE.RepeatWrapping;
                noiseTexture.wrapT = THREE.RepeatWrapping;
                noiseTexture.minFilter = THREE.LinearFilter;
                noiseTexture.magFilter = THREE.LinearFilter;
                noiseTexture.needsUpdate = true;
                log('Noise texture created');
                
                // Create simple shader material
                cloudMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0.0 },
                        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                        uChannel0: { value: noiseTexture },
                        uChannel1: { value: noiseTexture },
                        uDebugMode: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision highp float;
                        uniform float uTime;
                        uniform vec2 uResolution;
                        uniform vec2 uMouse;
                        uniform sampler2D uChannel0;
                        uniform sampler2D uChannel1;
                        uniform float uDebugMode;
                        varying vec2 vUv;
                        
                        // 3D noise function
                        float noise(in vec3 x) {
                            vec3 p = floor(x);
                            vec3 f = fract(x);
                            f = f * f * (3.0 - 2.0 * f);
                            vec2 uv = (p.xy + vec2(37.0, 239.0) * p.z) + f.xy;
                            vec2 rg = texture2D(uChannel0, (uv + 0.5) / 256.0).yx;
                            return mix(rg.x, rg.y, f.z) * 2.0 - 1.0;
                        }
                        
                        // Simple cloud density
                        float map(in vec3 p) {
                            vec3 q = p - vec3(0.0, 0.1, 1.0) * uTime * 0.1;
                            float f = 0.5 * noise(q);
                            q *= 2.0;
                            f += 0.25 * noise(q);
                            q *= 2.0;
                            f += 0.125 * noise(q);
                            return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
                        }
                        
                        void main() {
                            vec2 fragCoord = vUv * uResolution;
                            
                            // Debug modes
                            if (uDebugMode > 0.5 && uDebugMode < 1.5) {
                                // UV visualization
                                gl_FragColor = vec4(vUv, 0.0, 1.0);
                                return;
                            }
                            if (uDebugMode > 1.5 && uDebugMode < 2.5) {
                                // Screen coords
                                vec2 p = (2.0 * fragCoord - uResolution) / uResolution.y;
                                gl_FragColor = vec4(p * 0.5 + 0.5, 0.0, 1.0);
                                return;
                            }
                            if (uDebugMode > 2.5 && uDebugMode < 3.5) {
                                // Ray direction
                                vec2 p = (2.0 * fragCoord - uResolution) / uResolution.y;
                                vec3 rd = normalize(vec3(p.xy, 1.5));
                                gl_FragColor = vec4(rd * 0.5 + 0.5, 1.0);
                                return;
                            }
                            if (uDebugMode > 3.5 && uDebugMode < 4.5) {
                                // Noise texture
                                gl_FragColor = texture2D(uChannel0, vUv);
                                return;
                            }
                            if (uDebugMode > 4.5) {
                                // Solid blue
                                gl_FragColor = vec4(0.4, 0.6, 0.9, 1.0);
                                return;
                            }
                            
                            // Normal cloud rendering
                            vec2 p = (2.0 * fragCoord - uResolution) / uResolution.y;
                            
                            // Camera
                            float an = 0.5 * uTime * 0.1 + uMouse.x * 3.0;
                            vec3 ro = vec3(4.0 * sin(an), 0.5, 4.0 * cos(an));
                            vec3 ta = vec3(0.0, -1.0, 0.0);
                            vec3 ww = normalize(ta - ro);
                            vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
                            vec3 vv = cross(uu, ww);
                            vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);
                            
                            // Sky background
                            vec3 col = vec3(0.6, 0.71, 0.75) - rd.y * 0.2 * vec3(1.0, 0.5, 1.0) + 0.15;
                            
                            // Simple raymarch
                            float t = 0.0;
                            vec4 sum = vec4(0.0);
                            for (int i = 0; i < 64; i++) {
                                vec3 pos = ro + t * rd;
                                if (sum.a > 0.99 || pos.y < -3.0 || pos.y > 2.0) break;
                                
                                float den = map(pos);
                                if (den > 0.01) {
                                    vec4 c = vec4(mix(vec3(1.0, 0.95, 0.8), vec3(0.25, 0.3, 0.35), den), den);
                                    c.xyz = mix(c.xyz, col, 1.0 - exp(-0.003 * t * t));
                                    c.w *= 0.4;
                                    c.rgb *= c.a;
                                    sum += c * (1.0 - sum.a);
                                }
                                t += max(0.06, 0.02 * t);
                            }
                            
                            col = col * (1.0 - sum.w) + sum.xyz;
                            
                            gl_FragColor = vec4(col, 1.0);
                        }
                    `,
                    transparent: false,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                log('Shader material created');
                
                // Check for shader compilation errors
                renderer.compile(scene, camera);
                const glProgram = renderer.properties.get(cloudMaterial).programs;
                log('Shader compiled');
                
                // Create plane
                const geometry = new THREE.PlaneGeometry(2, 2);
                const mesh = new THREE.Mesh(geometry, cloudMaterial);
                mesh.frustumCulled = false;
                scene.add(mesh);
                log('Mesh added to scene');
                
                // Animate
                const startTime = Date.now();
                function animate() {
                    requestAnimationFrame(animate);
                    cloudMaterial.uniforms.uTime.value = (Date.now() - startTime) / 1000.0;
                    renderer.render(scene, camera);
                }
                animate();
                log('Animation started');
                
                // Resize handler
                window.addEventListener('resize', () => {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    cloudMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
                });
                
            } catch (error) {
                log('ERROR: ' + error.message);
                console.error(error);
            }
        }
        
        init();
    </script>
</body>
</html>
